{"version":3,"file":"parseBoxShadow.js","sourceRoot":"","sources":["../src/parseBoxShadow.ts"],"names":[],"mappings":";AAAA,gEAAgE;;;AAEhE,MAAM,UAAU,GAAG,eAAe,CAAC;AACnC,MAAM,SAAS,GAAG,eAAe,CAAC;AAClC,MAAM,UAAU,GAAG,qBAAqB,CAAC;AAEzC,MAAM,UAAU,GAAG,CAAC,GAAW,EAAE,EAAE;IACjC,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACnC,MAAM,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACtC,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAChC,MAAM,KAAK,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC;IAEjD,MAAM,IAAI,GAAG,KAAK;SACf,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,OAAO,CAAC;SAC5B,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC;SAC1B,GAAG,CAAC,KAAK,CAAC,CAAC;IACd,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,GAAG,IAAI,CAAC;IAElC,OAAO;QACL,KAAK;QACL,CAAC;QACD,CAAC;QACD,IAAI;QACJ,MAAM;QACN,KAAK;KACN,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,QAAQ,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACxD,MAAM,KAAK,GAAG,CAAC,CAAC,EAAE,EAAE;IAClB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG;QAAE,OAAO,CAAC,CAAC;IAC1C,MAAM,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;IACxB,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC;AAEK,MAAM,cAAc,GAAG,CAAC,GAAW,EAAE,EAAE,CAC5C,GAAG;KACA,KAAK,CAAC,UAAU,CAAC;KACjB,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;KACpB,GAAG,CAAC,UAAU,CAAC,CAAC;AAJR,QAAA,cAAc,kBAIN","sourcesContent":["// https://github.com/jxnblk/css-box-shadow/blob/master/index.js\n\nconst VALUES_REG = /,(?![^\\(]*\\))/;\nconst PARTS_REG = /\\s(?![^(]*\\))/;\nconst LENGTH_REG = /^[0-9]+[a-zA-Z%]+?$/;\n\nconst parseValue = (str: string) => {\n  const parts = str.split(PARTS_REG);\n  const inset = parts.includes(\"inset\");\n  const last = parts.slice(-1)[0];\n  const color = !isLength(last) ? last : undefined;\n\n  const nums = parts\n    .filter((n) => n !== \"inset\")\n    .filter((n) => n !== color)\n    .map(toNum);\n  const [x, y, blur, spread] = nums;\n\n  return {\n    inset,\n    x,\n    y,\n    blur,\n    spread,\n    color,\n  };\n};\n\nconst isLength = (v) => v === \"0\" || LENGTH_REG.test(v);\nconst toNum = (v) => {\n  if (!/px$/.test(v) && v !== \"0\") return v;\n  const n = parseFloat(v);\n  return !isNaN(n) ? n : v;\n};\n\nexport const parseBoxShadow = (str: string) =>\n  str\n    .split(VALUES_REG)\n    .map((s) => s.trim())\n    .map(parseValue);\n"]}